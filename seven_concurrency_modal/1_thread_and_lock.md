# 1. 스레드와 잠금장치  
스레드와 잠금장치는 모든 병렬적 아키텍처의 근간이 되는 기본이다.  
대부분의 언어들이 병렬적 제어를 위해 이를 제공한다.

실전 코드에서는 Thread를 직접 사용하는 일은 드물 것이다.  
하지만, 상위 수준의 내용을 이해하기 위해서는 기본이 되는 이러한 내용을 알아야 한다.

## 상호배제와 메모리 모델  
잠금장치를 사용하는 것은 한 번에 하나의 스레드만이 접근할 수 있도록 강제한다.  
이렇게 다른 공유 불가능하여 동시에 여러 스레드가 사용을 피하기 위한 알고리즘을 `상호배제(Mutual exclusion), Mutex`라고 한다.  
보통 critical section(임계 구역)이라 불리는 코드 영역에 의해 구현된다.

`Thread` : 하나의 논리적 흐름을 의미함  

### 공유 메모리 문제란?  
보통 값을 쓰기 위해서는 아래와 같은 프로세스를 통한다.  
    읽기 > 수정 > 쓰기

여기서 2개의 쓰레드가 동시에 읽기 과정에 오고, 수정을 진행했다고 하면,  
2를 더한 것이 아닌, 1을 더한 결과로 쓰기에 적용된다.  
즉, H/W 상에서 일어나는 일을 생각하면  
잘못된 결과를 만들어낸다.

그래서 `synchronized` 키워드를 이용하면 접근을 동기화 하므로,  
잠금장치를 이용하여 데이터 접근 시, 한 번에 하나의 쓰레드만이 접근할 수 있어  
이러한 문제를 해결할 수 있다.

## 메모리의 미스터리  
```java
answer = 42;
answerReady = true;
```
위 코드에서 어떤 라인이 먼저 실행이 될까?  
컴파일러나 CPU 실행 시, 어떤 것을 먼저 실행할지는 예측하기 어렵다.  
2번 째 줄이 먼저 실행 될 수도 있다는 것이 포인트다.

이는 컴파일러나 JVM, H/W에서 최적화를 수행하는 것이므로,  
이것 역시 메모리 문제를 일으킬 수 있다는 것.

## 메모리의 가시성  
값을 변경하는 메소드, 값을 읽는 메소드 2개가 있다면,  
모두 동기화를 시켜주어야 한다.  
아닌 경우, 값을 변경하는 중에 값을 읽어버려  
오래된 값을 보게될 수도 있다.  
이것은 문제가될 수 있다.

## 여러 개의 잠금 장치  
```java
synchronized (left) {
    synchronized (right) {
        // ...
    }
}
```
위 코드는 여러 개의 잠금장치를 적용한 예로,  
비효율적인 코드이면서 데드락이 발생할 가능성이 높아진다.  

이를 회피할 수 있는 방법은 아래와 같다.
    잠금장치에 사용할 개체를 미리 정해진 순서를 따르게 한다. (left와 right가 겹치지 않게끔)

## 외부 메서드의 위험  
종종 listener를 이용하여 여러 스레드에서 처리하는 경우가 있는데,  
이때도 역시 listener에 대한 동작을 동기화하고, 외부 메소드를 호출한다면  
데드락의 위험이 있다.

이를 피하기 위한 솔루션은 2가지가 있다.
- synchronized 메소드에서 외부 메소드 호출을 피하기
- 동기화 되는 영역을 한정지어 해결

# 정리  
잠금장치를 이용한 위험 요소 3가지를 알아봄.  
- 경쟁 조건
- 데드락
- 메모리 가시성

이를 피하기 위한 방법  
- 공유되는 메모리에 대한 접근 반드시 동기화
- 쓰는 쓰레드, 읽는 쓰레드 모두 동기화
- 여러 개의 잠금장치 이용 시 공통의 순서 주기
- 잠금장치 안에서 외부 메서드 호출X
- 잠금장치는 최대한 짧게 보유



